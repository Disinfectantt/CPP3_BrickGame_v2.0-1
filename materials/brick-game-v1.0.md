### Finite-state machines

A finite-state machine (FSM) in the theory of algorithms is a mathematical abstraction, a model of a discrete device that has one entry, one exit and at each moment of time is in one state out of a set of possible states.

During operation, the input of the FSM sequentially receives entry actions, and at the output the FSM generates exit signals. Transition from one internal state to another can occur not only from external action, but also spontaneously.

FSM can be used to describe algorithms for solving certain problems, as well as for modeling almost any process. A few examples:

- Artificial intelligence logic for games;
- Syntactic and lexical analysis;
- Complex components

Below are examples of using FSM to formalize the game logic of a few games from BrickGame.

### Frogger

![Frogger](../misc/images/frogger-game.png)

Frogger is one of the games for the Brickgame console. The game is a playing field on which the logs move, and by jumping over them, the player needs to direct the frog from one side to the other. If the player hits the water or the frog moves outside the playing field, the frog dies. The game ends when the player brings the frog to the other side or the last frog dies.

In order to formalize the logic of this game, the following variant of a finite-state machine can be introduced:

![Frogger's finite-state machine](../misc/images/frogger.jpg)

This FSM has the following states:

- Start is the state in which the game waits for the player to press the ready to play button.
- Spawn is the state in which the next frog is created.
- Moving is the main game state with user input processing - moving the frog along the lane left/right or jumping forward/backward.
- Shifting is the state that occurs after the timer expires, which shifts all objects on the lanes to the right, along with the frog.
- Collision is a state that occurs if the frog hits the water after jumping, or if the frog is outside the playing field after shifting logs.
- Reached the other side is the state that occurs when a frog reaches the  other side.
- Game over is the state that occurs after reaching the other side of the river or the last frog dies.

### Tetris

![Tetris](../misc/images/tetris-game.png)

Tetris is probably one of the most popular games for the Brickgame console. It's not rare for the console itself to be referred to as Tetris. The goal of the game is to score points for building lines from the blocks generated by the game. The next block generated by the game starts moving down the playing field until it reaches the lower boundary or collides with another block. The user can rotate the pieces and move them horizontally, trying to make rows. Once filled, the row is destroyed, the player gets points, and the blocks above the filled row go down. The game ends when the next piece stops in the topmost row.

In order to formalize the logic of this game, the following variant of a finite-state machine can be introduced:

![Tetrisâ€™s finite-state machine](../misc/images/tetris-fsm.png)

This FSM has the following states:

- Start is the state in which the game waits for the player to press the ready to play button.
- Spawn is the state the game enters when you create another block and choose the next block to spawn.
- Moving is the main game state with user input processing - rotating blocks/moving blocks horizontally.
- Shifting is the state the game enters after the timer expires. It moves the current block down one level.
- Attaching is the state the game enters after the current block "touches" the already fallen blocks or the ground. If filled rows are created, it is destroyed and the rest of the blocks are shifted down. If a block is stopped in the topmost row, the game enters the "game over" state.
- Game over is a game over.
