### Finite-state machines

A finite-state machine (FSM) in algorithm theory is a mathematical abstraction, a model of a discrete device that has an input, an output, and is in one of a set of possible states at any given time.

During operation, the input of the FSM receives input actions sequentially, and the output of the FSM generates output signals. Transition from one internal state to another can occur not only by external action, but also spontaneously.

FSMs can be used to describe algorithms for solving specific problems, as well as to model almost any process. Some examples:

- Artificial intelligence game logic;
- Syntactic and lexical analysis;
- Complex components.

Below are examples of using FSM to formalize the game logic of some games from BrickGame.

### Frogger

![Frogger](misc/images/frogger-game.png)

Frogger is one of the games for the Brickgame console. The game is a playing field on which logs are moving and the player has to guide the frog from one side to the other by jumping over them. If the player hits the water or the frog moves outside the playing field, the frog dies. The game ends when the player gets the frog to the other side, or when the last frog dies.

To formalize the logic of this game, the following variant of a finite-state machine can be introduced:

![Frogger's finite-state machine](misc/images/frogger-fsm.jpg)

This FSM has the following states:

- Start is the state where the game is waiting for the player to press the ready button.
- Spawn is the state where the next frog is created.
- Moving is the main game state with user input processing - moving the frog left/right along the path or jumping forward/backward.
- Shift is the state that occurs after the timer runs out, where all objects on the paths are shifted to the right along with the frog.
- Collision is a state that occurs when the frog hits the water after jumping, or when the frog is outside the playing field after moving logs.
- Reached the other side is the state that occurs when a frog reaches the other side.
- Game over is the state that occurs when the frog reaches the other side of the river, or when the last frog dies.

### Tetris

![Tetris](misc/images/tetris-game.png)

Tetris is probably one of the most popular games for the Brickgame console. It's not uncommon for the console itself to be called Tetris. The goal of the game is to score points by building lines of blocks generated by the game. The next block generated by the game starts moving down the playing field until it reaches the lower boundary or collides with another block. The user can rotate the blocks and move them horizontally, trying to make rows. Once a row is filled, it is destroyed, the player scores points, and the blocks above the filled row fall down. The game ends when the next piece stops in the top row.

To formalize the logic of this game, the following variant of a finite-state machine can be introduced:

![Tetris’s finite-state machine](misc/images/tetris-fsm.png)

This FSM has the following states:

- Start is the state in which the game waits for the player to press the ready button.
- Spawn is the state the game enters when you create another block and select the next block to spawn.
- Moving is the main game state with user input processing — rotating blocks/moving blocks horizontally.
- Move is the state the game enters after the timer runs out. It moves the current block down one level.
- Attaching is the state the game enters after the current block "touches" the already fallen blocks or the ground. If full rows are created, it is destroyed and the remaining blocks are moved down. If a block is stopped in the top row, the game enters the "game over" state.
- Game over is the end of the game.
